import: dist("math/dist")
logger: log("cards")

export: def Cards := []

def card([A], {B}) do
	let Class := class ! (A, B)
	Cards:put(Class)
	ret Class
end

fun resources_string(Resources) do
	Resources => (fun(Type, Count) '{Count} {Type}') join ", "
end

export: def AllResources := set(["Red", "Green", "Blue", "Orange"])

:>-------------------------------------------------------------------------------<

card: buy_resource(:points, :resource, weight is 25 - _, exclusive is nil, generate is; Player) do
	let Game := Player:game
	let Resource := random(AllResources)
	let Price := math::ceil(Game:values[Resource] ^ 2 * 50 / (0.5 + (Player:random)()))
	let Max := integer(Player:points / Price)
	Max >= 1 or ret nil
	let Amount := random(1 .. Max)
	ret buy_resource(Price * Amount, {Resource is Amount})
end

meth :name(Card: buy_resource) 'Buy {first(key(Card:resource))}'
meth :image(Card: buy_resource) 'card4-01'
meth :description(Card: buy_resource) 'Buy {resources_string(Card:resource)} for {Card:points} points.'
meth :cost(Card: buy_resource) '{Card:points} points'
meth :apply(Card: buy_resource, Player: any) do
	Player:points := old - Card:points
	for Resource, Amount in Card:resource do
		Player:resources[Resource] := old + Amount
	end
	ret '{Player:name} bought {resources_string(Card:resource)} for {Card:points} points.'
end

:>-------------------------------------------------------------------------------<

card: sell_resources(:resources, :points, weight is fun(Round) 4 * Round - 15 max 5, exclusive is nil, generate is; Player) do
	let Game := Player:game
	var Points := 0
	let Costs := {}
	for Resource in AllResources do
		if random(real) < 0.4 then
			let Max := Player:resources[Resource]
			Max >= 1 or next
			let Price := math::ceil(Game:values[Resource] ^ 2 * 50 / (1.5 - (Player:random)()))
			let Amount := random(1 .. Max)
			Points := old + (Amount * Price)
			Costs[Resource] := Amount
		end
	end
	first(Costs) or ret nil
	ret sell_resources(Costs, Points)
end

meth :name(Card: sell_resources) 'Sell Resources'
meth :image(Card: sell_resources) 'card1-05'
meth :description(Card: sell_resources) 'Sell {resources_string(Card:resources)} for {Card:points} points.'
meth :cost(Card: sell_resources) resources_string(Card:resources)
meth :apply(Card: sell_resources, Player: any) do
	Player:points := old + Card:points
	for Resource, Amount in Card:resources do
		Player:resources[Resource] := old - Amount
	end
	ret '{Player:name} sold {resources_string(Card:resources)} for {Card:points} points.'
end

:>-------------------------------------------------------------------------------<

card: improve_resource(:points, :resource, :amount, weight is fun 6, exclusive is nil, generate is; Player) do
	let Cost := math::ceil(150 / (3.0 - (Player:random)()))
	let Resource := random::key(Player:resources) or random(AllResources)
	let Max := Player:points div Cost
	Max > 0 or ret nil
	let Amount := 0.5 * random(1 .. Max)
	ret improve_resource(Cost * Amount, Resource, Amount)
end

meth :name(Card: improve_resource) 'Improve Resource'
meth :image(Card: improve_resource) 'card5-01'
meth :description(Card: improve_resource) 'Pay {Card:points} points to increase the efficiency of {Card:resource} by {Card:amount}.'
meth :cost(Card: improve_resource) '{Card:points} points'
meth :apply(Card: improve_resource, Player: any) do
	Player:points := old - Card:points
	let Value := Player:game:values[Card:resource] := old + Card:amount
	ret '{Player:name} paid {Card:points} points to increase the efficiency of {Card:resource} to {Value}.'
end

:>-------------------------------------------------------------------------------<

card: worsen_resource(:points, :resource, :amount, weight is fun 3, exclusive is nil, generate is; Player) do
	let Game := Player:game
	let Points := 5 * math::floor(10 / (2 + (Player:random)()))
	let Total := integer(sum(Player:resources))
	var N := random(1 .. Total)
	for Resource, Current in Player:resources do
		if Current >= N then
			let Amount := math::round(random(real), 5)
			Amount < Game:values[Resource] or next
			ret worsen_resource(Points, Resource, Amount)
		end
		N := old - Current
	end
end

meth :name(Card: worsen_resource) 'Worsen Resource'
meth :image(Card: worsen_resource) 'card5-06'
meth :description(Card: worsen_resource) 'Pay {Card:points} points to decrease the efficiency of {Card:resource} by {Card:amount}.'
meth :cost(Card: worsen_resource) '{Card:points} points'
meth :apply(Card: worsen_resource, Player: any) do
	Player:points := old - Card:points
	let Value := Player:game:values[Card:resource] := old - Card:amount
	ret '{Player:name} paid {Card:points} points to decrease the efficiency of {Card:resource} to {Value}.'
end

:>-------------------------------------------------------------------------------<

card: increase_luck(:points, weight is fun 4, exclusive is some, generate is; Player) do
	let Points := math::floor(Player:points / (2 + (Player:random)()))
	ret increase_luck(Points)
end

meth :name(Card: increase_luck) 'Increase Luck'
meth :image(Card: increase_luck) 'card2-14'
meth :description(Card: increase_luck) 'Pay {Card:points} points to increase your luck.'
meth :cost(Card: increase_luck) '{Card:points} points'
meth :apply(Card: increase_luck, Player: any) do
	Player:points := old - Card:points
	Player:luck := 1.0 - (1.0 - old * 0.9)
	Player:random := dist::triangular(0.0, Player:luck, 1.0) 
	ret '{Player:name} paid {Card:points} points to increase their luck to {math::round(Player:luck, 1000)}.'
end

:>-------------------------------------------------------------------------------<

card: delayed_buy_resource(:points, :resource, :delay, weight is fun(Round) (15 - Round) max 5, exclusive is nil, generate is; Player) do
	let Game := Player:game
	Game:round < 19 or ret nil
	let Resource := random(AllResources)
	let Delay := random(2 .. (10 - Game:round max 2))
	let Price := math::ceil(Game:values[Resource] ^ 2 * 50 / (0.5 + (Player:random)()) / (Delay ^ 1.5))
	let Max := integer(Player:points / Price)
	Max >= 1 or ret nil
	let Amount := random(1 .. Max)
	ret delayed_buy_resource(Price * Amount, {Resource is Amount}, Delay)
end

meth :name(Card: delayed_buy_resource) 'Buy {first(key(Card:resource))} in {Card:delay}'
meth :image(Card: delayed_buy_resource) 'card5-12'
meth :description(Card: delayed_buy_resource) 'Buy {resources_string(Card:resource)} for {Card:points} points after {Card:delay} rounds.'
meth :cost(Card: delayed_buy_resource) '{Card:points} points'
meth :apply(Card: delayed_buy_resource, Player: any) do
	Player:points := old - Card:points
	Player:invest(Card:delay;) do
		for Resource, Amount in Card:resource do
			Player:resources[Resource] := old + Amount
		end
		ret '{Player:name} bought {resources_string(Card:resource)} for {Card:points} points.'
	end
	ret '{Player:name} invested {Card:points} points for {resources_string(Card:resource)} in {Card:delay} rounds.'
end

:>-------------------------------------------------------------------------------<

card: delayed_sell_resources(:resource, :points, :price, :delay, weight is fun(Round) (15 - Round) max 5, exclusive is nil, generate is; Player) do
	let Game := Player:game
	Game:round < 18 or ret nil
	var Points := 0
	let Costs := {}
	let Delay := random(2 .. (20 - Game:round min 10))
	for Resource in AllResources do
		if random(real) < 0.4 then
			let Max := integer(random(1 .. Delay) ^ 1.5)
			let Price := math::ceil(Game:values[Resource] ^ 2 * 200 / (1.5 - (Player:random)()))
			let Amount := Player:resources[Resource] + random(1 .. Max)
			Points := old + (Amount * Price)
			Costs[Resource] := Amount
		end
	end
	first(Costs) or ret nil
	let Cost := math::ceil(Points / 10 / math::sqrt(Delay)) min math::ceil(Player:points / 2)
	ret delayed_sell_resources(Costs, Points, Cost, Delay)
end

meth :name(Card: delayed_sell_resources) 'Sell {first(key(Card:resource))} in {Card:delay}'
meth :image(Card: delayed_sell_resources) 'card4-08'
meth :description(Card: delayed_sell_resources) 'Sell {resources_string(Card:resource)} for {Card:points} points after {Card:delay} rounds. Failure costs {Card:points / 10} points.'
meth :cost(Card: delayed_sell_resources) '{Card:price} points'
meth :apply(Card: delayed_sell_resources, Player: any) do
	log::info('Cost =', Card:resource)
	for Resource, Amount in Card:resource do
		Player:targets[Resource]:inc(Amount)
	end
	Player:invest(Card:delay;) do
		let Missing := set()
		for Resource, Amount in Card:resource do
			Player:targets[Resource]:dec(Amount)
			if Player:resources[Resource] < Amount then
				Missing:insert(Resource)
			end
		end
		if Missing:count > 0 then
			Player:points := old - (Card:price / 10)
			ret '{Player:name} does not have enough {Missing, ", "} to complete their promise.'
		end
		for Resource, Amount in Card:resource do
			Player:resources[Resource] := old + Amount
		end
		Player:points := old + Card:points
		ret '{Player:name} sold {resources_string(Card:resource)} for {Card:points} points.'
	end
	Player:points := old - Card:price
	ret '{Player:name} paid {Card:price} points for a promise to sell {resources_string(Card:resource)} for {Card:points} in {Card:delay} rounds.'
end

:>-------------------------------------------------------------------------------<

card: steal_points(:target, :percent, :price, weight is fun 10, exclusive is nil, generate is; Player) do
	let Game := Player:game
	let Target := if random(boolean) = true then
		let Others := set(Game:players, Player != _)
		let Target := random(Others) or ret nil
		for Card in Player:choices do
			if Card in steal_points and Card:target = Target then
				ret nil
			end
		end
		Target
	else
		random(["Points"]:grow(key(Player:resources)))
	end
	let Percent := random(1 .. 10) * 5
	let Cost := math::ceil(Player:points * Percent / (100 * (Player::random)() + 50))
	ret steal_points(Target, Percent, Cost)
end

meth :name(Card: steal_points) 'Steal {Card:percent}%'
meth :image(Card: steal_points) 'card4-04'
meth :description(Card: steal_points) do
	let Target := Card:target
	if Target in string then
		'Steal {Card:percent}% points from player with most {Target}.'
	else
		'Steal {Card:percent}% points from {Target:name}.'
	end
end
meth :cost(Card: steal_points) '{Card:price} points'
meth :apply(Card: steal_points, Player: any) do
	let Target := Card:target
	let Other := if Target in string then
		let Players := Player:game:players
		if Target = "Points" then
			max2(dup(Players) -> :points)[1]
		else
			max2(dup(Players) -> :resources -> _[Target])[1]
		end
	else
		Target
	end
	Player:points := old - Card:price
	Other = Player and ret '{Player:name} tried to steal from themselves! It wasn\'t very effective.'
	let Amount := math::floor(Card:percent * Other:points / 100)
	Player:game:events:put(;) do
		if Other:effects["protection"] > 0 then
			ret '{Player:name} tried to steal from {Other:name} but they had protection.'
		end
		Other:points := old - Amount
		Player:points := old + Amount
		ret '{Player:name} stole {Amount} points from {Other:name}.'
	end
	ret '{Player:name} attempted to steal {Amount} points from {Other:name}.'
end

:>-------------------------------------------------------------------------------<

card: protect(:rounds, :price, weight is fun 10, exclusive is true, generate is; Player) do
	let Rounds := random(1 .. 5)
	let Cost := math::ceil(Player:points * (10 + Rounds) / (100 * (Player::random)() + 50))
	ret protect(Rounds, Cost)
end

meth :name(Card: protect) 'Protection'
meth :image(Card: protect) 'card4-06'
meth :description(Card: protect) 'Prevent negative effects for the next {Card:rounds} rounds.'
meth :cost(Card: protect) '{Card:price} points'
meth :apply(Card: protect, Player: any) do
	Player:points := old - Card:price
	Player:effects["protection", fun 0] := old max Card:rounds
	ret '{Player:name} paid {Card:price} points for {Card:rounds} of protection.'
end

:>-------------------------------------------------------------------------------<

card: confusion(:price, :target, weight is fun 5, exclusive is nil, generate is; Player) do
	let Game := Player:game
	let Others := set(Game:players, Player != _)
	let Target := random(Others) or ret nil
	for Card in Player:choices do
		if Card in confusion and Card:target = Target then
			ret nil
		end
	end
	let Cost := math::ceil(Player:points * 5 / (100 * (Player::random)() + 50))
	ret confusion(Cost, Target)
end

meth :name(Card: confusion) 'Cast Confusion'
meth :image(Card: confusion) 'card1-07'
meth :description(Card: confusion) 'Cast confusion on {Card:target:name} for the next round.'
meth :cost(Card: confusion) '{Card:price} points'
meth :apply(Card: confusion, Player: any) do
	let Other := Card:target
	Player:points := old - Card:price
	Player:game:events:put(;) do
		if Other:effects["protection"] > 0 then
			ret '{Player:name} tried to confuse {Other:name} but they had protection.'
		end
		Other:effects["confusion"] := 1
		ret '{Player:name} successfully confused {Other:name}.'
	end
	ret '{Player:name} paid {Card:price} points to cast confusion on {Other:name}.'
end

:>-------------------------------------------------------------------------------<

card: silence(:price, :target, weight is fun 5, exclusive is nil, generate is; Player) do
	let Game := Player:game
	let Others := set(Game:players, Player != _)
	let Target := random(Others) or ret nil
	for Card in Player:choices do
		if Card in silence and Card:target = Target then
			ret nil
		end
	end
	let Cost := math::ceil(Player:points * 5 / (100 * (Player::random)() + 50))
	ret silence(Cost, Target)
end

meth :name(Card: silence) 'Cast Silence'
meth :image(Card: silence) 'card1-08'
meth :description(Card: silence) 'Cast silence on {Card:target:name} for the next round.'
meth :cost(Card: silence) '{Card:price} points'
meth :apply(Card: silence, Player: any) do
	let Other := Card:target
	Player:points := old - Card:price
	Player:game:events:put(;) do
		if Other:effects["protection"] > 0 then
			ret '{Player:name} tried to silence {Other:name} but they had protection.'
		end
		Other:effects["silence"] := 1
		ret '{Player:name} successfully silenced {Other:name}.'
	end
	ret '{Player:name} paid {Card:price} points to cast silence on {Other:name}.'
end

:>-------------------------------------------------------------------------------<

card: convert_resource(:price, :resource, weight is fun 10, exclusive is true, generate is; Player) do
	let (Resource, Target) := max2(Player:targets)
	Target > 0 or ret nil
	let Cost := math::ceil(Player:points * random(1 .. 10) / 10)
	ret convert_resource(Cost, Resource)
end

meth :name(Card: convert_resource) 'Convert Resources'
meth :image(Card: convert_resource) 'card1-02'
meth :description(Card: convert_resource) 'Convert all of your resources to {Card:resource}.'
meth :cost(Card: convert_resource) '{Card:price} points'
meth :apply(Card: convert_resource, Player: any) do
	Player:points := old - Card:price
	let Total := sum(Player:resources)
	for Amount in Player:resources do Amount := 0 end
	Player:resources[Card:resource] := Total
	ret '{Player:name} paid {Card:price} points to convert all of their resources to {Card:resource}.'
end

:>-------------------------------------------------------------------------------<

card: shuffle_resources(:price, weight is fun 5, exclusive is true, generate is; Player) do
	let Cost := math::ceil(Player:points * random(1 .. 10) / 10)
	ret shuffle_resources(Cost)
end

meth :name(Card: shuffle_resources) 'Shuffle Resources'
meth :image(Card: shuffle_resources) 'card4-22'
meth :description(Card: shuffle_resources) 'Shuffles everyones resources.'
meth :cost(Card: shuffle_resources) '{Card:price} points'
meth :apply(Card: shuffle_resources, Player: any) do
	Player:points := old - Card:price
	let Game := Player:game
	let Resources := list(key(Game:values))
	for Player in Game:players do
		let Total := sum(Player:resources)
		for Amount in Player:resources do Amount := 0 end
		Player:resources grow count2(1 .. Total;) random(Resources)
	end
	ret '{Player:name} paid {Card:price} points to shuffle everyone\'s resources.'
end

:>-------------------------------------------------------------------------------<

card: auto_buy_resources(:resource, :price, :rounds, weight is fun 10, exclusive is nil, generate is; Player) do
	let Game := Player:game
	let Rounds := random(2 .. 10)
	let Resource := random(AllResources)
	let Price := math::ceil(Game:values[Resource] ^ 2 * (Rounds * 5 + 50) / (0.5 + (Player:random)()))
	auto_buy_resources(Resource, Price, Rounds)
end

meth :name(Card: auto_buy_resources) 'Auto Buy Resources'
meth :image(Card: auto_buy_resources) 'card2-09'
meth :description(Card: auto_buy_resources) 'Automatically buy {Card:resource} for {Card:price} for the next {Card:rounds} rounds.'
meth :cost(Card: auto_buy_resources) 'Varies'
meth :apply(Card: auto_buy_resources, Player: any) do
	let Game := Player:game
	var Rounds := Card:rounds
	let Id := uuid()
	Player:automations[Id] := '{Card:resource} for {Card:price} for {Card:rounds} rounds'
	fun buy() do
		Player:automations[Id] or ret
		let Price := Card:price
		let Amount := math::floor(Player:points / Card:price)
		Player:points := old - (Amount * Price)
		Player:resources[Card:resource] := old + Amount
		if Rounds:dec > 0 then
			Game:events:put(buy)
		else
			Player:automations:delete(Id)
		end
		ret '{Player:name} automatically bought {Amount} {Card:resource} for {Amount * Price}.'
	end
	Game:events:put(buy)
	ret '{Player:name} will automatically buy {Card:resource} for {Card:price} for the next {Card:rounds} rounds.'
end

:>-------------------------------------------------------------------------------<

card: cancel_automation(:id, :automation, weight is fun 25, exclusive is true, generate is; Player) do
	let Id := random(key(Player:automations)) or ret nil
	cancel_automation(Id, Player:automations[Id])
end

meth :name(Card: cancel_automation) 'Cancel Automation'
meth :image(Card: cancel_automation) 'card1-13'
meth :description(Card: cancel_automation) 'Cancel automation \"{Card:automation}\".'
meth :cost(Card: cancel_automation) 'Free'
meth :apply(Card: cancel_automation, Player: any) do
	Player:automations:delete(Card:id)
	ret '{Player:name} cancelled automation \"{Card:automation}\".'
end

:>-------------------------------------------------------------------------------<

card: combine_resources(:resources, :result, weight is fun 15, exclusive is nil, generate is; Player) do
	let Totals := map(Player:resources):sort2(; R1, R2, V1, V2) V1 > V2
	
end
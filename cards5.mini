import: dist("math/dist")

export: def Cards := []

def card([A], {B}) do
	let Class := class ! (A, B)
	Cards:put(Class)
	ret Class
end

fun resources_string(Resources) do
	Resources => (fun(Type, Count) '{Count} {Type}') join ", "
end

export: def AllResources := set(["Red", "Green", "Blue", "Orange"])

:>-------------------------------------------------------------------------------<

card: buy_resource(:points, :resource, weight is 20 - _, generate is; Player) do
	let Game := Player:game
	let Resource := random(AllResources)
	let Price := math::ceil(Game:values[Resource] ^ 2 * 50 / (0.5 + (Player:random)()))
	let Max := integer(Player:points / Price)
	Max >= 1 or ret nil
	let Amount := random(1 .. Max)
	ret buy_resource(Price * Amount, {Resource is Amount})
end

meth :name(Card: buy_resource) 'Buy {first(key(Card:resource))}'
meth :image(Card: buy_resource) 'card4-01'
meth :description(Card: buy_resource) 'Buy {resources_string(Card:resource)} for {Card:points} points.'
meth :cost(Card: buy_resource) '{Card:points} points'
meth :apply(Card: buy_resource, Player: any) do
	Player:points := old - Card:points
	for Resource, Amount in Card:resource do
		Player:resources[Resource] := old + Amount
	end
	ret '{Player:name} bought {resources_string(Card:resource)} for {Card:points} points.'
end

:>-------------------------------------------------------------------------------<

card: sell_resources(:resources, :points, weight is fun(Round) 4 * Round - 12 max 0, generate is; Player) do
	let Game := Player:game
	var Points := 0
	let Costs := {}
	for Resource in AllResources do
		if random(real) < 0.4 then
			let Max := Player:resources[Resource]
			Max >= 1 or next
			let Price := math::ceil(Game:values[Resource] ^ 2 * 50 / (1.5 - (Player:random)()))
			let Amount := random(1 .. Max)
			Points := old + (Amount * Price)
			Costs[Resource] := Amount
		end
	end
	first(Costs) or ret nil
	ret sell_resources(Costs, Points)
end

meth :name(Card: sell_resources) 'Sell Resources'
meth :image(Card: sell_resources) 'card1-05'
meth :description(Card: sell_resources) 'Sell {resources_string(Card:resources)} for {Card:points} points.'
meth :cost(Card: sell_resources) resources_string(Card:resources)
meth :apply(Card: sell_resources, Player: any) do
	Player:points := old + Card:points
	for Resource, Amount in Card:resources do
		Player:resources[Resource] := old - Amount
	end
	ret '{Player:name} sold {resources_string(Card:resources)} for {Card:points} points.'
end

:>-------------------------------------------------------------------------------<

card: improve_resource(:points, :resource, :amount, weight is fun 6, generate is; Player) do
	let Points := 5 * math::floor(10 / (2 + (Player:random)()))
	let Total := integer(sum(Player:resources))
	var N := random(1 .. Total)
	for Resource, Current in Player:resources do
		if Current >= N then
			let Amount := math::round(random(real), 5)
			Amount > 0 or next
			ret improve_resource(Points, Resource, Amount)
		end
		N := old - Current
	end
end

meth :name(Card: improve_resource) 'Improve Resource'
meth :image(Card: improve_resource) 'card5-01'
meth :description(Card: improve_resource) 'Pay {Card:points} points to increase the efficiency of {Card:resource} by {Card:amount}.'
meth :cost(Card: improve_resource) '{Card:points} points'
meth :apply(Card: improve_resource, Player: any) do
	Player:points := old - Card:points
	let Value := Player:game:values[Card:resource] := old + Card:amount
	ret '{Player:name} paid {Card:points} points to increase the efficiency of {Card:resource} to {Value}.'
end

:>-------------------------------------------------------------------------------<

card: worsen_resource(:points, :resource, :amount, weight is fun 6, generate is; Player) do
	let Game := Player:game
	let Points := 5 * math::floor(10 / (2 + (Player:random)()))
	let Total := integer(sum(Player:resources))
	var N := random(1 .. Total)
	for Resource, Current in Player:resources do
		if Current >= N then
			let Amount := math::round(random(real), 5)
			Amount < Game:values[Resource] or next
			ret worsen_resource(Points, Resource, Amount)
		end
		N := old - Current
	end
end

meth :name(Card: worsen_resource) 'Worsen Resource'
meth :image(Card: worsen_resource) 'card5-06'
meth :description(Card: worsen_resource) 'Pay {Card:points} points to decrease the efficiency of {Card:resource} by {Card:amount}.'
meth :cost(Card: worsen_resource) '{Card:points} points'
meth :apply(Card: worsen_resource, Player: any) do
	Player:points := old - Card:points
	let Value := Player:game:values[Card:resource] := old - Card:amount
	ret '{Player:name} paid {Card:points} points to decrease the efficiency of {Card:resource} to {Value}.'
end

:>-------------------------------------------------------------------------------<

card: increase_luck(:points, weight is fun 4, generate is; Player) do
	let Points := math::floor(Player:points / (2 + (Player:random)()))
	ret increase_luck(Points)
end

meth :name(Card: increase_luck) 'Increase Luck'
meth :image(Card: increase_luck) 'card2-14'
meth :description(Card: increase_luck) 'Pay {Card:points} points to increase your luck.'
meth :cost(Card: increase_luck) '{Card:points} points'
meth :apply(Card: increase_luck, Player: any) do
	Player:points := old - Card:points
	Player:luck := 1.0 - (1.0 - old * 0.9)
	Player:random := dist::triangular(0.0, Player:luck, 1.0) 
	ret '{Player:name} paid {Card:points} points to increase their luck to {math::round(Player:luck, 1000)}.'
end

:>-------------------------------------------------------------------------------<

card: delayed_buy_resource(:points, :resource, :delay, weight is fun(Round) (15 - Round) max 0, generate is; Player) do
	let Game := Player:game
	Game:round < 19 or ret nil
	let Resource := random(AllResources)
	let Delay := random(2 .. (10 - Game:round))
	let Price := math::ceil(Game:values[Resource] ^ 2 * 50 / (0.5 + (Player:random)()) / (Delay ^ 1.5))
	let Max := integer(Player:points / Price)
	Max >= 1 or ret nil
	let Amount := random(1 .. Max)
	ret delayed_buy_resource(Price * Amount, {Resource is Amount}, Delay)
end

meth :name(Card: delayed_buy_resource) 'Buy {first(key(Card:resource))} in {Card:delay}'
meth :image(Card: delayed_buy_resource) 'card1-04'
meth :description(Card: delayed_buy_resource) 'Buy {resources_string(Card:resource)} for {Card:points} points after {Card:delay} rounds.'
meth :cost(Card: delayed_buy_resource) '{Card:points} points'
meth :apply(Card: delayed_buy_resource, Player: any) do
	Player:points := old - Card:points
	Player:invest(Card:delay;) do
		for Resource, Amount in Card:resource do
			Player:resources[Resource] := old + Amount
		end
		ret '{Player:name} bought {resources_string(Card:resource)} for {Card:points} points.'
	end
	ret '{Player:name} invested {Card:points} points for {resources_string(Card:resource)} in {Card:delay} rounds.'
end

:>-------------------------------------------------------------------------------<

card: delayed_sell_resource(:resource, :points, :cost, :delay, weight is fun(Round) (15 - Round) max 0, generate is; Player) do
	let Game := Player:game
	Game:round < 19 or ret nil
	var Points := 0
	let Costs := {}
	let Delay := random(2 .. (10 - Game:round))
	for Resource in AllResources do
		if random(real) < 0.4 then
			let Max := Player:resources[Resource] + random(1 .. Delay) * random(1 .. Delay)
			let Price := math::ceil(Game:values[Resource] ^ 2 * 100 / (1.5 - (Player:random)()) / math::sqrt(Delay))
			let Amount := random(1 .. Max)
			Points := old + (Amount * Price)
			Costs[Resource] := Amount
		end
	end
	first(Costs) or ret nil
	let Cost := math::ceil(Points / 10 / math::sqrt(Delay)) min math::ceil(Player:points / 2)
	ret delayed_sell_resource(Costs, Points, Cost, Delay)
end

meth :name(Card: delayed_sell_resource) 'Sell {first(key(Card:resource))} in {Card:delay}'
meth :image(Card: delayed_sell_resource) 'card2-10'
meth :description(Card: delayed_sell_resource) 'Sell {resources_string(Card:resource)} for {Card:points} points after {Card:delay} rounds.'
meth :cost(Card: delayed_sell_resource) '{Card:cost} points'
meth :apply(Card: delayed_sell_resource, Player: any) do
	Player:invest(Card:delay;) do
		let Missing := set()
		for Resource, Amount in Card:resource do
			if Player:resources[Resource] < Amount then
				Missing:insert(Resource)
			end
		end
		if Missing:count > 0 then
			ret '{Player:name} does not have enough {Missing, ", "} to complete their promise.'
		end
		for Resource, Amount in Card:resource do
			Player:resources[Resource] := old + Amount
		end
		Player:points := old + Card:points
		ret '{Player:name} sold {resources_string(Card:resource)} for {Card:points} points.'
	end
	Player:points := old - Card:cost
	ret '{Player:name} paid {Card:cost} points for a promise to sell {resources_string(Card:resource)} for {Card:points} in {Card:delay} rounds.'
end
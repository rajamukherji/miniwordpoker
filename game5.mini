import: glib("gir/GLib")
import: gobject("gir/GObject")
import: json("fmt/json")
import: uuid("util/uuid")
import: stat("math/stat")
import: dist("math/dist")
import: cards("cards5")
logger: log("game")

:<
import: game("game")
let Game := game::game("Test")
let P1 := game::player("Ann")
let P2 := game::player("Bob")
let P3 := game::player("Cat")
let P4 := game::player("Dan")
P1 join Game
P2 join Game
Game:start
>:

export: class: game(
	:name, :owner, :password, :state, :players, :countdown, :limit,
	:round, :history, :events, :rollover, :values, :mult,
	
	state is enum("Initial", "Starting", "Running", "Choosing", "Scoring", "Ending"),
	init is fun(Game, Name, Owner, Password) do
		Game:name := Name
		Game:owner := Owner
		Game:password := Password
		Game:state := game::state::Initial
		Game:players := []
		Game:history := []
		Game:events := []
	end
)

export: class: player(:name, :callback, :game, :history, :points, :resources,
	:choices, :choice, :investments, :effects, :luck, :random, :targets, :automations,
	init is fun(Player, Name, Callback) do
		Player:name := Name
		Player:callback := Callback or fun(Player, Event, Data) do
			print(Event, " ", Data, "\n")
		end
	end
)

meth :emit(Player: player, [Args]) do
	Player:callback ! [Player]:grow(Args)
end

meth :state(Player: player) do
	if let Game := Player:game then
		ret {
			"name" is Game:name, "state" is string(Game:state),
			"countdown" is Game:countdown, "limit" is Game:limit,
			"points" is Player:points,
			"owner" is Game:owner = Player and true,
			"players" is list(Game:players; Other) {
				"name" is Other:name, "points" is Other:points,
				"self" is Other = Player and true
			}
		}
	end
end

meth :join(Player: player, Game: game) do
	Player:game and error("StateError", "Player already in game")
	Player:game := Game
	Player:points := 100
	Player:resources := map(cards::AllResources;) 1
	Player:history := []
	Player:choices := []
	Player:choice := nil
	Player:investments := []
	Player:targets := map(cards::AllResources;) 0
	Player:effects := {}
	Player:automations := {}
	Player:luck := 0.5
	Player:random := dist::triangular(0.0, 0.5, 1.0)
	Player:resources := map(cards::AllResources;) 1
	for Other in Game:players do
		Other:emit("game/join", {"name" is Player:name, "points" is Player:points, "resources" is Player:resources})
	end
	Game:players:put(Player)
	ret Player:state
end

let Games := []

meth :start(Player: player, Game: game) do
	Game:state = game::state::Initial or error("StateError", "Invalid state")
	Game:owner = Player or error("StateError", "Invalid owner")
	Game:state := game::state::Starting
	Game:countdown := Game:limit := 3
	Game:history := []
	Game:round := 0
	Game:events := []
	Game:values := map(cards::AllResources;) 1
	for Player in Game:players do
		Player:emit("round/starting", {
			"countdown" is Game:countdown, "limit" is Game:limit
		})
	end
	Games:put(Game)
end

meth :leave(Player: player, Game: game) do
	Game = Player:game or error("StateError", "Player not in game")
	Player:game := nil
	let Players := Game:players
	let Index := Players:find(Player)
	Players:delete(Index)
	Player:emit("game/leave", {})
	for Player in Game:players do
		Player:emit("game/leave", {"player" is Index})
	end
	if Players:length = 0 then
		Games:filter(_ != Game)
	end
end

meth :choose(Player: player, Index: any) do
	Player:choice := Player:choices[Index{}]
	ret true
end

meth :invest(Player: player, Delay: integer, Action: function) do
	Player:investments:put((Player:game:round + Delay, Action))
end

fun card_colour(Card) 'hsl({#(type(Card):name) mod 360},50%,80%)'

class: silenced()

meth :name(Card: silenced) 'Silenced!'
meth :image(Card: silenced) 'card5-14'
meth :description(Card: silenced) 'You are silenced.'
meth :cost(Card: silenced) '-'
meth :apply(Card: silenced, Player: any) do
	ret '{Player:name} was silenced.'
end

glib::timeout_add(0, 1000;) do
	for Game in Games do
		ref Countdown := Game:countdown
		ref State := Game:state
		let Players := Game:players
		if Countdown and Countdown:dec = 0 then
			switch State: game::state
			case "Starting" do
				Game:round := 0
				Game:rollover := 0
				Game:values := map(cards::AllResources;) 1
				Game:mult := 0.0
				State := game::state::Running
				Countdown := Game:limit := 1
				for Index, Player in Players do
					Player:points := 100
					Player:resources := map(cards::AllResources;) 1
					Player:history := []
					Player:choices := []
					Player:choice := nil
					Player:investments := []
					Player:targets := map(cards::AllResources;) 0
					Player:effects := {}
					Player:automations := {}
					Player:luck := 0.5
					Player:random := dist::triangular(0.0, 0.5, 1.0)
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points, "resources" is Player:resources,
						"log" is [], "round" is Game:round,
						"values" is Game:values,
						"index" is Index,
						"players" is list(Game:players; Player) {
							"points" is Player:points, "resources" is Player:resources
						}
					})
				end
			case "Running" do
				Game:round:inc
				let Log := []
				for Player in Players do
					Player:choices:empty
					for (Term, Reward) in Player:investments:remove(; (Term, Reward)) Term = Game:round do
						Log:put('{Player:name}\'s investment matured: {Reward(Player)}')
					end
				end
				if let Round := 20 >= Game:round then
					Game:mult := random(real) / 5
					State := game::state::Choosing
					Countdown := Game:limit := 15
					log::info('Card weights = ', map(cards::Cards, ::weight, _(Round)))
					let choice := random::choice ! list(cards::Cards; Card) Card::weight(Round)
					for Index, Player in Players do
						if Player:effects["silence"] then
							Player:choices := list(1 .. 6;) silenced()
						else
							let Cards := Player:choices := []
							for I in 1 .. 6 do
								for I in 1 .. 100 do
									let Class := cards::Cards[choice()]
									log::info('Attempting to generate ', Class)
									if Class::exclusive and first(Cards ->? (_ in Class)) then
										next
									end
									if let Card := Class::generate(Player) then
										Cards:put(Card)
										exit
									end
								else
									error("CardError", "Failed to generate a card!")
								end
							end
						end
						Player:choice := nil
						let Choices := list(Player:choices; Choice) {
							"name" is Choice:name,
							"image" is Choice:image,
							"description" is Choice:description,
							"cost" is Choice:cost,
							"colour" is card_colour(Choice)
						}
						log::info('{Player:name}: {Player:effects}')
						Player:effects["confusion"] and Choices:shuffle
						Player:emit("round/choosing", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points, "resources" is Player:resources,
							"log" is Log, "round" is Game:round,
							"choices" is Choices,
							"values" is Game:values,
							"index" is Index,
							"players" is list(Game:players; Player) {
								"points" is Player:points, "resources" is Player:resources
							}
						})
					end
				else
					State := game::state::Scoring
					Countdown := Game:limit := 20
					for Player in Players do
						Player:emit("round/scoring", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points, "resources" is Player:resources,
							"log" is Log, "round" is Game:round,
							"players" is list(Game:players; Player) {
								"name" is Player:name,
								"points" is Player:points, "resources" is Player:resources
							}
						})
					end
				end
			case "Choosing" do
				let Log := []
				for Player in Players do
					for Value in Player:effects do
						Value:dec
					end
					Player:effects:filter(_ > 0)
				end
				for Player in list(Players):shuffle do
					if let Choice := Player:choice then
						Log:put(Choice:apply(Player))
					end
				end
				for Event in Game:events:splice do
					Log:put(Event(){})
				end
				State := game::state::Running
				Countdown := Game:limit := 10
				for Index, Player in Players do
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points, "resources" is Player:resources,
						"log" is Log, "round" is Game:round,
						"values" is Game:values,
						"index" is Index,
						"players" is list(Game:players; Player) {
							"points" is Player:points, "resources" is Player:resources
						}
					})
				end
			case "Scoring" do
				State := game::state::Ending
				Countdown := Game:limit := 1
				for Player in Players do
					Player:emit("round/ending", {
						"countdown" is Countdown, "limit" is Game:limit,
						"players" is list(Players; Player) {"points" is Player:points}
					})
				end
			case "Ending" do
				State := game::state::Starting
				Countdown := Game:limit := 3
				for Player in Players do
					Player:emit("round/starting", {
						"countdown" is Countdown,  "limit" is Game:limit
					})
				end
			end
		elseif State = game::state::Running then
			for Player in Players do
				for Resource, Amount in Player:resources do
					Player:points := old + (Amount * Game:values[Resource])
				end
			end
		end
	on Error do
		log::error(Error)
	end
	ret true
end

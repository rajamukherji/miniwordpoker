import: glib("gir/GLib")
import: gobject("gir/GObject")
import: json("fmt/json")
import: uuid("util/uuid")
import: stat("math/stat")
logger: log("main")

:<
import: game("game")
let Game := game::game("Test")
let P1 := game::player("Ann")
let P2 := game::player("Bob")
let P3 := game::player("Cat")
let P4 := game::player("Dan")
P1 join Game
P2 join Game
Game:start
>:

export: class: game(
	:name, :owner, :password, :state, :players, :countdown, :limit,
	:round, :history, :events, :rollover, :values,
	
	state is enum("Initial", "Starting", "Running", "Choosing", "Scoring", "Ending"),
	init is fun(Game, Name, Owner, Password) do
		Game:name := Name
		Game:owner := Owner
		Game:password := Password
		Game:state := game::state::Initial
		Game:players := []
		Game:history := []
		Game:events := []
	end
)

export: class: player(:name, :callback, :game, :history, :points, :resources,
	:choices, :choice, :investments, :effects,
	init is fun(Player, Name, Callback) do
		Player:name := Name
		Player:callback := Callback or fun(Player, Event, Data) do
			print(Event, " ", Data, "\n")
		end
	end
)

meth :emit(Player: player, [Args]) do
	Player:callback ! [Player]:grow(Args)
end

meth :state(Player: player) do
	if let Game := Player:game then
		ret {
			"name" is Game:name, "state" is string(Game:state),
			"countdown" is Game:countdown, "limit" is Game:limit,
			"points" is Player:points,
			"owner" is Game:owner = Player and true,
			"players" is list(Game:players; Other) {
				"name" is Other:name, "points" is Other:points,
				"self" is Other = Player and true
			}
		}
	end
end

meth :join(Player: player, Game: game) do
	Player:game and error("StateError", "Player already in game")
	Player:game := Game
	Player:points := 0
	Player:dictionaries := 1
	for Other in Game:players do
		Other:emit("game/join", {"name" is Player:name, "points" is Player:points, "dictionaries" is Player:dictionaries})
	end
	Game:players:put(Player)
	ret Player:state
end

let Games := []

fun change_verb(Change) do
	if Change > 0 then
		'<span class=\"positive\">➕</span> Gain'
	elseif Change < 0 then
		'<span class=\"negative\">➖</span> Lose'
	end
end

fun change_verb_past(Change) do
	if Change > 0 then
		'<span class=\"positive\">➕</span> Gained'
	elseif Change < 0 then
		'<span class=\"negative\">➖</span> Lost'
	end
end

class: choice()

class: adjust_dictionaries(choice, :price, :change)
meth :generate(Choice: adjust_dictionaries, Player: player) do
end
meth :name(Choice: adjust_dictionaries) '{change_verb(Choice:change)} Dictionaries'
meth :image(Choice: adjust_dictionaries) "dictionary"
meth :description(Choice: adjust_dictionaries) '{change_verb(Choice:change)} {math::abs(Choice:change)} dictionaries'
meth :cost(Choice: adjust_dictionaries) '{Choice:price} points'
meth :apply(Choice: adjust_dictionaries, Player: player) do
	Player:points := old - Choice:price
	Player:dictionaries := old + Choice:change
	ret if Choice:price != 0 then
		'{Player:name} spent {Choice:price} points to {change_verb(Choice:change)} {math::abs(Choice:change)} dictionaries'
	else
		'{Player:name} {change_verb_past(Choice:change)} {math::abs(Choice:change)} dictionaries'
	end
end

class: adjust_words(choice, :price, :change)
meth :name(Choice: adjust_words) '{change_verb(Choice:change)} Points'
meth :image(Choice: adjust_words) "buy_words"
meth :description(Choice: adjust_words) '{change_verb(Choice:change)} {math::abs(Choice:change)} points'
meth :cost(Choice: adjust_words) '{Choice:price} dictionaries'
meth :apply(Choice: adjust_words, Player: player) do
	Player:dictionaries := old - Choice:price
	Player:points := old + Choice:change
	ret if Choice:price != 0 then
		'{Player:name} spent {Choice:price} dictionaries to {change_verb(Choice:change)} {math::abs(Choice:change)} points'
	else
		'{Player:name} {change_verb_past(Choice:change)} {math::abs(Choice:change)} points'
	end
end

class: block_card(choice, :card)
meth :name(Choice: block_card) "Block"
meth :image(Choice: block_card) "block_player"
meth :description(Choice: block_card) 'Block \"{Choice:card:description}\"'
meth :cost(Choice: block_card) "Free"
meth :apply(Choice: block_card, Player: player) do
	ret '{Player:name} blocked \"{Choice:card:description}\"'
end

class: swap_words(choice, :with, :blocked)
meth :name(Choice: swap_words) "Swap Points"
meth :image(Choice: swap_words) "swap_words_sad"
meth :description(Choice: swap_words) 'Swap points with {Choice:with:name}'
meth :cost(Choice: swap_words) "Free"
meth :apply(Choice: swap_words, Player: player) do
	if Choice:blocked then
		ret '{Player:name} was blocked from swapping points with {Choice:with:name}'
	else
		exchange(Player:points, Choice:with:points)
		ret '{Player:name} swapped their points with {Choice:with:name}'
	end
end

class: swap_dictionaries(choice, :with, :blocked)
meth :name(Choice: swap_dictionaries) "Swap Dictionaries"
meth :image(Choice: swap_dictionaries) "mute_player"
meth :description(Choice: swap_dictionaries) 'Swap dictionaries with {Choice:with:name}'
meth :cost(Choice: swap_dictionaries) "Free"
meth :apply(Choice: swap_dictionaries, Player: player) do
	if Choice:blocked then
		ret '{Player:name} was blocked from swapping dictionaries with {Choice:with:name}'
	else
		exchange(Player:dictionaries, Choice:with:dictionaries)
		ret '{Player:name} swapped their dictionaries with {Choice:with:name}'
	end
end

class: steal_words(choice, :with, :change, :blocked)
meth :name(Choice: steal_words) "Steal Points"
meth :image(Choice: steal_words) "threaten_player"
meth :description(Choice: steal_words) 'Steal {Choice:change} points from {Choice:with:name}'
meth :cost(Choice: steal_words) "Free"
meth :apply(Choice: steal_words, Player: player) do
	if Choice:blocked then
		ret '{Player:name} was blocked from stealing {Choice:change} points from {Choice:with:name}'
	else
		Choice:with:points := old - Choice:change
		Player:points := old + Choice:change
		ret '{Player:name} stole {Choice:change} points from {Choice:with:name}'
	end
end

class: unique_choice(choice, :reward, :penalty)
meth :name(Choice: unique_choice) "Choose Wisely"
meth :image(Choice: unique_choice) "scramble"
meth :description(Choice: unique_choice) 'If only you choose this then {Choice:reward:description}, otherwise {Choice:penalty:description}'
meth :cost(Choice: unique_choice) "Free?"
meth :apply(Choice: unique_choice, Player: player) do
	let Players := Player:game:players
	let Index := Player:choices:find(Choice)
	if count(Players ->? fun(Other) Other:choice = Other:choices[Index]) > 1 then
		Choice:penalty:apply(Player)
	else
		Choice:reward:apply(Player)
	end
end

class: lottery(choice, :price, :jackpot, :winners)
meth :name(Choice: lottery) "Lottery"
meth :image(Choice: lottery) "buy_ticket"
meth :description(Choice: lottery) 'Enter lottery for a chance to win a share of the jackpot. Roll-over jackpot is {Choice:jackpot}'
meth :cost(Choice: lottery) '{Choice:price} points'
meth :apply(Choice: lottery, Player: player) do
	Player:points := old - Choice:price
	if Player in Choice:winners then
		Player:points := old + (Choice:jackpot / Choice:winners:size)
		ret '{Player:name} bought a lottery ticket for {Choice:cost} and won {Choice:jackpot / Choice:winners:size}'
	else
		ret '{Player:name} bought a lottery ticket for {Choice:cost} but lost'
	end
end

class: investment(choice, :price, :term, :reward)
meth :name(Choice: investment) "Investment"
meth :image(Choice: investment) "double_dictionary"
meth :description(Choice: investment) '{Choice:reward:description} after {Choice:term} rounds'
meth :cost(Choice: investment) '{Choice:price} points'
meth :apply(Choice: investment, Player: player) do
	Player:points := old - Choice:price
	Player:investments:put((Player:game:round + Choice:term, Choice:reward))
	ret '{Player:name} invested {Choice:price} points to {Choice:reward:description} in {Choice:term} rounds'
end

class: multiply_words(choice, :multiple)
meth :name(Choice: multiply_words) "Multiply Points"
meth :image(Choice: multiply_words) "share_letters"
meth :description(Choice: multiply_words) '✖Multiply points by {Choice:multiple}'
meth :cost(Choice: multiply_words) "Free"
meth :apply(Choice: multiply_words, Player: player) do
	Player:points := old * Choice:multiple
	ret '{Player:name} multiplied their points by {Choice:multiple}'
end

class: confuse_player(choice, :player)
meth :name(Choice: confuse_player) "Confuse Player"
meth :image(Choice: confuse_player) "serendipity"
meth :description(Choice: confuse_player) 'Make {Choice:player:name} pick a random card'
meth :cost(Choice: confuse_player) "Free"
meth :apply(Choice: confuse_player, Player: player) do
	Player:confused := 1
	ret '{Player:name} cast confusion on {Choice:player:name}'
end

meth :start(Player: player, Game: game) do
	Game:state = game::state::Initial or error("StateError", "Invalid state")
	Game:owner = Player or error("StateError", "Invalid owner")
	Game:state := game::state::Starting
	Game:countdown := Game:limit := 3
	Game:history := []
	Game:round := 0
	Game:events := []
	for Player in Game:players do
		Player:emit("round/starting", {
			"countdown" is Game:countdown, "limit" is Game:limit
		})
	end
	Games:put(Game)
end

meth :leave(Player: player, Game: game) do
	Game = Player:game or error("StateError", "Player not in game")
	Player:game := nil
	let Players := Game:players
	let Index := Players:find(Player)
	Players:delete(Index)
	Player:emit("game/leave", {})
	for Player in Game:players do
		Player:emit("game/leave", {"player" is Index})
	end
	if Players:length = 0 then
		Games:filter(_ != Game)
	end
end

meth :choose(Player: player, Index: any) do
	Player:choice := Player:choices[Index{}]
	ret true
end

def Points := polynomial("Points")
def Rate := polynomial("Rate")

fun round_points(Points) do
	switch Points: integer
	case 1000 .. 100000000 do 1000
	case 500 .. 1000 do 500
	case 250 .. 500 do 250
	case 100 .. 250 do 100
	case 50 .. 100 do 50
	case 25 .. 50 do 25
	case 10 .. 25 do 10
	case 5 .. 10 do 5
	else 1
	end
end

glib::timeout_add(0, 1000;) do
	for Game in Games do
		ref Countdown := Game:countdown
		ref State := Game:state
		let Players := Game:players
		if Countdown and Countdown:dec = 0 then
			switch State: game::state
			case "Starting" do
				Game:round := 0
				Game:rollover := 0
				State := game::state::Running
				Countdown := Game:limit := 1
				for Player in Players do
					Player:points := 10
					Player:dictionaries := 1
					Player:history := []
					Player:choices := []
					Player:choice := nil
					Player:investments := []
					Player:confused := nil
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points, "dictionaries" is Player:dictionaries,
						"log" is [], "round" is Game:round,
						"players" is list(Game:players; Player) {
							"points" is Player:points, "dictionaries" is Player:dictionaries
						}
					})
				end
			case "Running" do
				Game:round:inc
				let Log := []
				for Player in Players do
					Player:choices:empty
					for (Term, Reward) in Player:investments:remove(; (Term, Reward)) Term = Game:round do
						Log:put('{Player:name}\'s investment matured: {Reward:apply(Player)}')
					end
				end
				Game:events:empty
				if Game:round <= 10 then
					State := game::state::Choosing
					Countdown := Game:limit := 10
					let MeanPoints := stat::mean(Players, :points)
					let MeanRate := stat::mean(Players, :dictionaries)
					var Remaining := 4
					loop
						while Remaining > 0
						let Choice := switch nil: random
						case 0.2 do
							let A1 := switch nil: random
							case 5 do 0
							case 2 do 0.1
							case 1 do 0.2
							case 1 do 0.3
							end
							let B1 := round_points(MeanPoints * random(real) / 2)
							let A2 := switch nil: random
							case 5 do 0
							case 1 do 0.1
							case 0.2 do 0.2
							end
							let B2 := MeanRate * random(0 .. 2) / 5
							for Player in Players do
								Player:choices:put(adjust_words(
									math::ceil(A2 * Player:dictionaries + B2),
									math::ceil(A1 * Player:points + B1)
								))
							end
						case 0.3 do
							let A1 := switch nil: random
							case 5 do 0
							case 2 do 0.1
							case 1 do 0.2
							case 1 do 0.3
							end
							let B1 := random(1 .. 5)
							let A2 := switch nil: random
							case 5 do 0
							case 1 do 0.1
							case 0.2 do 0.2
							end
							let B2 := MeanPoints * random(1 .. 3) / 4
							for Player in Players do
								Player:choices:put(adjust_dictionaries(
									math::ceil(A2 * Player:points + B2),
									math::ceil(A1 * Player:dictionaries + B1)
								))
							end
						case 0.1 do
							let Other := max2(dup(Players), :points)[1]
							let Choice := swap_words(Other)
							let Block := block_card(Choice)
							for Player in Players do
								if Player = Other then
									Player:choices:put(Block)
								else
									Player:choices:put(Choice)
								end
							end
							Game:events:put(;) do
								if Other:choice = Block then
									Choice:blocked := 1
								end
								nil
							end
						case 0.1 do
							let Other := random(Players)
							let Change := switch nil: random
							case 5 do round_points(Other:points / 5)
							case 2 do round_points(Other:points / 3)
							case 1 do round_points(Other:points / 2)
							end
							let Choice := steal_words(Other, Change)
							let Block := block_card(Choice)
							for Player in Players do
								if Player = Other then
									Player:choices:put(Block)
								else
									Player:choices:put(Choice)
								end
							end
							Game:events:put(;) do
								if Other:choice = Block then
									Choice:blocked := 1
								end
								nil
							end
						case 0.1 do
							let A1 := switch nil: random
							case 5 do 0.2
							case 2 do 0.3
							case 1 do 0.4
							end
							let B1 := round_points(MeanPoints * random(real))
							let A2 := switch nil: random
							case 5 do -0.3
							case 2 do -0.4
							case 1 do -0.5
							end
							let B2 := round_points(-MeanPoints * random(real) / 2)
							for Player in Players do
								Player:choices:put(unique_choice(
									adjust_words(0, math::ceil(A1 * Player:points + B1)),
									adjust_words(0, math::ceil(A2 * Player:points + B2))
								))
							end
						case 0.1 do
							let Change := math::ceil(MeanPoints * random(1 .. 3) / 4)
							let Others := list(Players):cycle
							for Player in Players; Other in Others do
								Player:choices:put(steal_words(Other, Change))
							end
						case 0.1 do
							let Others := list(Players):cycle
							for Player in Players; Other in Others do
								Player:choices:put(swap_words(Other))
							end
						case 0.1 do
							let Others := list(Players):cycle
							for Player in Players; Other in Others do
								Player:choices:put(confuse_player(Other))
							end
						case 0.2 do
							Game:rollover or next
							let Lottery := lottery(10, Game:rollover + 100)
							Game:rollover := nil
							Game:events:put(;) do
								let Entered := list(Players ->? fun(Player) Player:choice = Lottery)
								let Winners := Lottery:winners := set(Entered ->? fun random(real) < 0.05)
								Lottery:jackpot := old + 50 * Entered:count
								if Winners:count = 0 then
									Game:rollover := Lottery:jackpot
									ret 'Nobody won the jackpot of {Lottery:jackpot} points, it rolls over to next time'
								else
									Game:rollover := 0
									ret 'There were {Winners:size} winners of the jackpot of {Lottery:jackpot} points'
								end
							end
							for Player in Players do
								Player:choices:put(Lottery)
							end
						case 0.1 do
							Game:round < 10 or next
							let Reward := switch nil: random
							case 1 do
								adjust_words(0, round_points(MeanPoints * random(real) * 2))
							case 1 do
								multiply_words(random(1 .. 10))
							case 1 do
								swap_words(max2(dup(Players), :points)[1])
							end
							let Term := random(1 .. (10 - Game:round))
							let A2 := switch nil: random
							case 5 do 0.1
							case 1 do 0.2
							case 0.2 do 0.3
							end
							let B2 := math::ceil(MeanPoints * random(1 .. 4) / 4)
							for Player in Players do
								Player:choices:put(investment(math::ceil(A2 * Player:points + B2), Term, Reward))
							end
						end
						Remaining:dec
					end
					for Player in Players do
						Player:choice := nil
						let Choices := list(Player:choices; Choice) {
							"name" is Choice:name,
							"image" is Choice:image,
							"description" is Choice:description,
							"cost" is Choice:cost
						}
						Player:confused and Choices:shuffle
						Player:emit("round/choosing", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points, "dictionaries" is Player:dictionaries,
							"log" is Log, "round" is Game:round,
							"choices" is Choices,
							"players" is list(Game:players; Player) {
								"points" is Player:points, "dictionaries" is Player:dictionaries
							}
						})
					end
				else
					State := game::state::Scoring
					Countdown := Game:limit := 20
					for Player in Players do
						Player:emit("round/scoring", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points, "dictionaries" is Player:dictionaries,
							"log" is Log, "round" is Game:round,
							"players" is list(Game:players; Player) {
								"name" is Player:name,
								"points" is Player:points, "dictionaries" is Player:dictionaries
							}
						})
					end
				end
			case "Choosing" do
				for Player in Players do
					Player:confused := nil
				end
				let Log := []
				for Event in Game:events do
					Log:put(Event(){})
				end
				for Player in list(Players):shuffle do
					if let Choice := Player:choice then
						Log:put(Choice:apply(Player))
					end
				end
				State := game::state::Running
				Countdown := Game:limit := 10
				for Player in Players do
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points, "dictionaries" is Player:dictionaries,
						"log" is Log, "round" is Game:round,
						"players" is list(Game:players; Player) {
							"points" is Player:points, "dictionaries" is Player:dictionaries
						}
					})
				end
			case "Scoring" do
				State := game::state::Ending
				Countdown := Game:limit := 1
				for Player in Players do
					Player:emit("round/ending", {
						"countdown" is Countdown, "limit" is Game:limit,
						"players" is list(Players; Player) {"points" is Player:points}
					})
				end
			case "Ending" do
				State := game::state::Starting
				Countdown := Game:limit := 3
				for Player in Players do
					Player:emit("round/starting", {
						"countdown" is Countdown,  "limit" is Game:limit
					})
				end
			end
		elseif State = game::state::Running then
			for Player in Players do
				Player:points := old + Player:dictionaries
			end
		end
	on Error do
		log::error(Error)
	end
	ret true
end

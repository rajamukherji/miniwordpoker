import: glib("gir/GLib")
import: gobject("gir/GObject")
import: json("fmt/json")
import: uuid("util/uuid")
import: stat("math/stat")
logger: log("main")

:<
import: game("game")
let Game := game::game("Test")
let P1 := game::player("Ann")
let P2 := game::player("Bob")
let P3 := game::player("Cat")
let P4 := game::player("Dan")
P1 join Game
P2 join Game
Game:start
>:

export: class: game(
	:name, :owner, :password, :state, :players, :countdown, :limit,
	:round, :history, :events, :rollover,
	
	state is enum("Initial", "Starting", "Running", "Choosing", "Scoring", "Ending"),
	init is fun(Game, Name, Owner, Password) do
		Game:name := Name
		Game:owner := Owner
		Game:password := Password
		Game:state := game::state::Initial
		Game:players := []
		Game:history := []
		Game:events := []
	end
)

export: class: player(:name, :callback, :game, :history, :words, :dictionaries, :choices, :choice,
	init is fun(Player, Name, Callback) do
		Player:name := Name
		Player:callback := Callback or fun(Player, Event, Data) do
			print(Event, " ", Data, "\n")
		end
	end
)

meth :emit(Player: player, [Args]) do
	Player:callback ! [Player]:grow(Args)
end

meth :state(Player: player) do
	if let Game := Player:game then
		ret {
			"name" is Game:name, "state" is string(Game:state),
			"countdown" is Game:countdown, "limit" is Game:limit,
			"words" is Player:words,
			"owner" is Game:owner = Player and true,
			"players" is list(Game:players; Other) {
				"name" is Other:name, "words" is Other:words,
				"self" is Other = Player and true
			}
		}
	end
end

meth :join(Player: player, Game: game) do
	Player:game and error("StateError", "Player already in game")
	Player:game := Game
	Player:words := 0
	Player:dictionaries := 1
	for Other in Game:players do
		Other:emit("game/join", {"name" is Player:name, "words" is Player:words, "dictionaries" is Player:dictionaries})
	end
	Game:players:put(Player)
	ret Player:state
end

let Games := []

fun change_verb(Change) do
	if Change > 0 then
		'<span class=\"positive\">▲</span> Increase'
	elseif Change < 0 then
		'<span class=\"negative\">▲</span> Decrease'
	else
		'<span class=\"neutral\">▬</span> Leave'
	end
end

class: choice()

class: adjust_dictionaries(choice, :price, :change)
meth :name(Choice: adjust_dictionaries) '{change_verb(Choice:change)} Dictionaries'
meth :image(Choice: adjust_dictionaries) "dictionary"
meth :description(Choice: adjust_dictionaries) '{change_verb(Choice:change)} dictionaries by {math::abs(Choice:change)}'
meth :cost(Choice: adjust_dictionaries) '{Choice:price} words'
meth :apply(Choice: adjust_dictionaries, Player: player) do
	Player:words := old - Choice:price
	Player:dictionaries := old + Choice:change
	ret '{Player:name} spent {Choice:price} words to {change_verb(Choice:change)} their dictionaries by {Choice:change}'
end

class: adjust_words(choice, :price, :change)
meth :name(Choice: adjust_words) '{change_verb(Choice:change)} Words'
meth :image(Choice: adjust_words) "buy_words"
meth :description(Choice: adjust_words) 'Change own words to {Choice:change}'
meth :cost(Choice: adjust_words) '{Choice:price} dictionaries'
meth :apply(Choice: adjust_words, Player: player) do
	Player:dictionaries := old - Choice:price
	Player:words := old + Choice:change
	ret '{Player:name} spent {Choice:price} dictionaries to {change_verb(Choice:change)} their words by {Choice:change}'
end

class: block_card(choice, :card)
meth :name(Choice: block_card) "Block"
meth :image(Choice: block_card) "block_player"
meth :description(Choice: block_card) 'Prevent \"{Choice:card:description}\"'
meth :cost(Choice: block_card) "Free"
meth :apply(Choice: block_card, Player: player) do
	Choice:card:blocked := 1
	ret '{Player:name} blocked \"{Choice:card:description}\"'
end

class: swap_words(choice, :with, :blocked)
meth :name(Choice: swap_words) "Swap Words"
meth :image(Choice: swap_words) "swap_words_sad"
meth :description(Choice: swap_words) 'Swap words with {Choice:with:name}'
meth :cost(Choice: swap_words) "Free"
meth :apply(Choice: swap_words, Player: player) do
	if Choice:blocked then
		ret '{Player:name} was blocked from swapping words with {Choice:with:name}'
	else
		exchange(Player:words, Choice:with:words)
		ret '{Player:name} swapped their words with {Choice:with:name}'
	end
end

class: swap_dictionaries(choice, :with, :blocked)
meth :name(Choice: swap_dictionaries) "Swap Dictionaries"
meth :image(Choice: swap_dictionaries) "mute_player"
meth :description(Choice: swap_dictionaries) 'Swap dictionaries with {Choice:with:name}'
meth :cost(Choice: swap_dictionaries) "Free"
meth :apply(Choice: swap_dictionaries, Player: player) do
	if Choice:blocked then
		ret '{Player:name} was blocked from swapping dictionaries with {Choice:with:name}'
	else
		exchange(Player:dictionaries, Choice:with:dictionaries)
		ret '{Player:name} swapped their dictionaries with {Choice:with:name}'
	end
end

class: steal_words(choice, :with, :change, :blocked)
meth :name(Choice: steal_words) "Steal Points"
meth :image(Choice: steal_words) "threaten_player"
meth :description(Choice: steal_words) 'Steal {Choice:change} words from {Choice:with:name}'
meth :cost(Choice: steal_words) "Free"
meth :apply(Choice: steal_words, Player: player) do
	if Choice:blocked then
		ret '{Player:name} was blocked from stealing {Choice:change} words from {Choice:with:name}'
	else
		Choice:with:words := old - Choice:change
		Player:words := old + Choice:change
		ret '{Player:name} stole {Choice:change} words from {Choice:with:name}'
	end
end

class: unique_choice(choice, :reward, :penalty)
meth :name(Choice: unique_choice) "Choose Wisely"
meth :image(Choice: unique_choice) "scramble"
meth :description(Choice: unique_choice) 'If only you choose this option then {Choice:reward:description}, otherwise {Choice:penalty:description}'
meth :cost(Choice: unique_choice) "Free?"
meth :apply(Choice: unique_choice, Player: player) do
	let Players := Player:game:players
	let Index := Player:choices:find(Choice)
	if count(Players ->? fun(Other) Other:choice = Other:choices[Index]) > 1 then
		Choice:penalty:apply(Player)
	else
		Choice:reward:apply(Player)
	end
end

class: lottery(choice, :price, :jackpot, :winners)
meth :name(Choice: lottery) "Lottery"
meth :image(Choice: lottery) "buy_ticket"
meth :description(Choice: lottery) 'Enter lottery for a chance to win a share of the jackpot. Roll-over jackpot is {Choice:jackpot}'
meth :cost(Choice: lottery) '{Choice:price} words'
meth :apply(Choice: lottery, Player: player) do
	Player:words := old - Choice:price
	if Player in Choice:winners then
		Player:words := old + (Choice:jackpot / Choice:winners:size)
		ret '{Player:name} bought a lottery ticket for {Choice:cost} and won {Choice:jackpot / Choice:winners:size}'
	else
		ret '{Player:name} bought a lottery ticket for {Choice:cost} but lost'
	end
end

meth :start(Player: player, Game: game) do
	Game:state = game::state::Initial or error("StateError", "Invalid state")
	Game:owner = Player or error("StateError", "Invalid owner")
	Game:state := game::state::Starting
	Game:countdown := Game:limit := 3
	Game:history := []
	Game:round := 0
	Game:events := []
	for Player in Game:players do
		Player:emit("round/starting", {
			"countdown" is Game:countdown, "limit" is Game:limit
		})
	end
	Games:put(Game)
end

meth :leave(Player: player, Game: game) do
	Game = Player:game or error("StateError", "Player not in game")
	Player:game := nil
	let Players := Game:players
	let Index := Players:find(Player)
	Players:delete(Index)
	Player:emit("game/leave", {})
	for Player in Game:players do
		Player:emit("game/leave", {"player" is Index})
	end
	if Players:length = 0 then
		Games:filter(_ != Game)
	end
end

meth :choose(Player: player, Index: any) do
	Player:choice := Player:choices[Index{}]
	ret true
end

def Points := polynomial("Points")
def Rate := polynomial("Rate")

fun round_points(Points) do
	switch Points: integer
	case 1000 .. 100000000 do 1000
	case 500 .. 1000 do 500
	case 250 .. 500 do 250
	case 100 .. 250 do 100
	case 50 .. 100 do 50
	case 25 .. 50 do 25
	case 10 .. 25 do 10
	case 5 .. 10 do 5
	else 1
	end
end

glib::timeout_add(0, 1000;) do
	for Game in Games do
		ref Countdown := Game:countdown
		ref State := Game:state
		let Players := Game:players
		if Countdown and Countdown:dec = 0 then
			switch State: game::state
			case "Starting" do
				Game:round := 0
				Game:rollover := 0
				State := game::state::Running
				Countdown := Game:limit := 1
				for Player in Players do
					Player:words := 10
					Player:dictionaries := 1
					Player:history := []
					Player:choices := []
					Player:choice := nil
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"words" is Player:words, "dictionaries" is Player:dictionaries,
						"log" is [], "round" is Game:round,
						"players" is list(Game:players; Player) {
							"words" is Player:words, "dictionaries" is Player:dictionaries
						}
					})
				end
			case "Running" do
				if Game:round:inc <= 10 then
					State := game::state::Choosing
					Countdown := Game:limit := 10
					let MeanPoints := stat::mean(Players, :words)
					let MeanRate := stat::mean(Players, :dictionaries)
					Game:events:empty
					for Player in Players do
						Player:choices:empty
					end
					var Remaining := 4
					loop
						print('Remaining cards = {Remaining}\n')
						while Remaining > 0
						let Choice := switch nil: random
						case 0.2 do
							let A1 := switch nil: random
							case 10 do 0
							case 2 do 0.1
							case 1 do 0.2
							end
							let B1 := round_points(MeanPoints * random(real) / 2)
							let A2 := switch nil: random
							case 5 do 0
							case 1 do 0.1
							case 0.2 do 0.2
							end
							let B2 := MeanRate * random(0 .. 2) / 5
							for Player in Players do
								Player:choices:put(adjust_words(
									A2 * Player:dictionaries + B2,
									A1 * Player:words + B1
								))
							end
						case 0.3 do
							let A1 := switch nil: random
							case 10 do 0
							case 2 do 0.1
							case 1 do 0.2
							end
							let B1 := random(0 .. 5)
							let A2 := switch nil: random
							case 5 do 0
							case 1 do 0.1
							case 0.2 do 0.2
							end
							let B2 := MeanPoints * random(1 .. 3) / 4
							for Player in Players do
								Player:choices:put(adjust_dictionaries(
									A2 * Player:words + B2,
									A1 * Player:dictionaries + B1
								))
							end
						case 0.1 do
							let Best := max2(dup(Players), :words)[1]
							let Choice := swap_words(Best)
							for Player in Players do
								if Player = Best then
									Player:choices:put(block_card(Choice))
								else
									Player:choices:put(Choice)
								end
							end
						case 0.1 do
							let Other := random(Players)
							let Change := switch nil: random
							case 5 do round_points(Other:words / 5)
							case 2 do round_points(Other:words / 3)
							case 1 do round_points(Other:words / 2)
							end
							let Choice := steal_words(Other, Change)
							for Player in Players do
								if Player = Other then
									Player:choices:put(block_card(Choice))
								else
									Player:choices:put(Choice)
								end
							end
						case 0.1 do
							let A1 := switch nil: random
							case 10 do 0.2
							case 2 do 0.3
							case 1 do 0.4
							end
							let B1 := round_points(MeanPoints * random(real))
							let A2 := switch nil: random
							case 10 do 0.8
							case 2 do 0.7
							case 1 do 0.6
							end
							let B2 := round_points(-MeanPoints * random(real) / 2)
							for Player in Players do
								Player:choices:put(unique_choice(
									adjust_words(0, A1 * Player:words + B1),
									adjust_words(0, A2 * Player:words + B2)
								))
							end
						case 0.1 do
							let Change := MeanPoints * random(1 .. 3) / 4
							let Others := list(Players):shuffle
							for Player in Players; Other in Others do
								let Choice := steal_words(Other, Change)
								Player:choices:put(Choice)
							end
						case 0.1 do
							let Others := list(Players):shuffle
							for Player in Players; Other in Others do
								Player:choices:put(swap_words(Other))
							end
						case 0.1 do
							Game:rollover or next
							let Lottery := lottery(10, Game:rollover + 100)
							Game:rollover := nil
							Game:events:put(;) do
								let Entered := list(Players ->? fun(Player) Player:choice = Lottery)
								let Winners := Lottery:winners := set(Entered ->? fun random(real) < 0.05)
								Lottery:jackpot := old + 50 * Entered:count
								if Winners:count = 0 then
									Game:rollover := Lottery:jackpot
									ret 'Nobody won the jackpot of {Lottery:jackpot} words, it rolls over to next time'
								else
									Game:rollover := 0
									ret 'There were {Winners:size} winners of the jackpot of {Lottery:jackpot} words'
								end
							end
							for Player in Players do
								Player:choices:put(Lottery)
							end
						end
						Remaining:dec
					end
					for Player in Players do
						Player:choice := nil
						Player:emit("round/choosing", {
							"countdown" is Countdown, "limit" is Game:limit,
							"words" is Player:words, "dictionaries" is Player:dictionaries,
							"choices" is list(Player:choices; Choice) {
								"name" is Choice:name,
								"image" is Choice:image,
								"description" is Choice:description,
								"cost" is Choice:cost
							},
							"players" is list(Game:players; Player) {
								"words" is Player:words, "dictionaries" is Player:dictionaries
							}
						})
					end
				else
					State := game::state::Scoring
					Countdown := Game:limit := 20
					for Player in Players do
						Player:emit("round/scoring", {
							"countdown" is Countdown, "limit" is Game:limit,
							"words" is Player:words, "dictionaries" is Player:dictionaries,
							"players" is list(Game:players; Player) {
								"name" is Player:name,
								"words" is Player:words, "dictionaries" is Player:dictionaries
							}
						})
					end
				end
			case "Choosing" do
				let Log := []
				for Event in Game:events do
					Log:put(Event())
				end
				for Player in Players do
					if let Choice := Player:choice then
						Log:put(Choice:apply(Player))
					end
				end
				State := game::state::Running
				Countdown := Game:limit := 10
				for Player in Players do
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"words" is Player:words, "dictionaries" is Player:dictionaries,
						"log" is Log, "round" is Game:round,
						"players" is list(Game:players; Player) {
							"words" is Player:words, "dictionaries" is Player:dictionaries
						}
					})
				end
			case "Scoring" do
				State := game::state::Ending
				Countdown := Game:limit := 1
				for Player in Players do
					Player:emit("round/ending", {
						"countdown" is Countdown, "limit" is Game:limit,
						"players" is list(Players; Player) {"words" is Player:words}
					})
				end
			case "Ending" do
				State := game::state::Starting
				Countdown := Game:limit := 3
				for Player in Players do
					Player:emit("round/starting", {
						"countdown" is Countdown,  "limit" is Game:limit
					})
				end
			end
		elseif State = game::state::Running then
			for Player in Players do
				Player:words := old + Player:dictionaries
			end
		end
	on Error do
		log::error(Error)
	end
	ret true
end

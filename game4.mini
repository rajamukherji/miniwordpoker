import: glib("gir/GLib")
import: gobject("gir/GObject")
import: json("fmt/json")
import: uuid("util/uuid")
import: stat("math/stat")
logger: log("main")

:<
import: game("game")
let Game := game::game("Test")
let P1 := game::player("Ann")
let P2 := game::player("Bob")
let P3 := game::player("Cat")
let P4 := game::player("Dan")
P1 join Game
P2 join Game
Game:start
>:

export: class: game(
	:name, :owner, :password, :state, :players, :countdown, :limit,
	:round, :history, :events, :rollover,
	
	state is enum("Initial", "Starting", "Running", "Choosing", "Scoring", "Ending"),
	init is fun(Game, Name, Owner, Password) do
		Game:name := Name
		Game:owner := Owner
		Game:password := Password
		Game:state := game::state::Initial
		Game:players := []
		Game:history := []
		Game:events := []
	end
)

export: class: player(:name, :callback, :game, :history, :points, :rate, :choices, :choice,
	init is fun(Player, Name, Callback) do
		Player:name := Name
		Player:callback := Callback or fun(Player, Event, Data) do
			print(Event, " ", Data, "\n")
		end
	end
)

meth :emit(Player: player, [Args]) do
	Player:callback ! [Player]:grow(Args)
end

meth :state(Player: player) do
	if let Game := Player:game then
		ret {
			"name" is Game:name, "state" is string(Game:state),
			"countdown" is Game:countdown, "limit" is Game:limit,
			"points" is Player:points,
			"owner" is Game:owner = Player and true,
			"players" is list(Game:players; Other) {
				"name" is Other:name, "points" is Other:points,
				"self" is Other = Player and true
			}
		}
	end
end

meth :join(Player: player, Game: game) do
	Player:game and error("StateError", "Player already in game")
	Player:game := Game
	Player:points := 0
	Player:rate := 1
	for Other in Game:players do
		Other:emit("game/join", {"name" is Player:name, "points" is Player:points, "rate" is Player:rate})
	end
	Game:players:put(Player)
	ret Player:state
end

let Games := []

class: choice()

class: adjust_rate(choice, :price, :change)
meth :name(Choice: adjust_rate) "Change Rate"
meth :description(Choice: adjust_rate) 'Change own rate to {Choice:change}'
meth :cost(Choice: adjust_rate) '{Choice:price} points'
meth :apply(Choice: adjust_rate, Player: player) do
	Player:points := old - Choice:price
	Player:rate := Choice:change
	ret '{Player:name} spent {Choice:price} points to change their rate to {Player:rate}'
end

class: adjust_points(choice, :price, :change)
meth :name(Choice: adjust_points) "Change Points"
meth :description(Choice: adjust_points) 'Change own points to {Choice:change}'
meth :cost(Choice: adjust_points) '{Choice:price} rate'
meth :apply(Choice: adjust_points, Player: player) do
	Player:rate := old - Choice:price
	Player:points := Choice:change
	ret '{Player:name} spent {Choice:price} rate to change their points to {Player:points}'
end

class: swap_points(choice, :with)
meth :name(Choice: swap_points) "Swap Points"
meth :description(Choice: swap_points) 'Swap points with {Choice:with:name}'
meth :cost(Choice: swap_points) "Free"
meth :apply(Choice: swap_points, Player: player) do
	exchange(Player:points, Choice:with:points)
	ret '{Player:name} swapped their points with {Choice:with:name}'
end

class: swap_rate(choice, :with)
meth :name(Choice: swap_rate) "Swap Rate"
meth :description(Choice: swap_rate) 'Swap rate with {Choice:with:name}'
meth :cost(Choice: swap_rate) "Free"
meth :apply(Choice: swap_rate, Player: player) do
	exchange(Player:rate, Choice:with:rate)
	ret '{Player:name} swapped their rate with {Choice:with:name}'
end

class: steal_points(choice, :with, :change)
meth :name(Choice: steal_points) "Steal Points"
meth :description(Choice: steal_points) 'Steal {Choice:change} points from {Choice:with:name}'
meth :cost(Choice: steal_points) "Free"
meth :apply(Choice: steal_points, Player: player) do
	Choice:with:points := old - Choice:change
	Player:points := old + Choice:change
	ret '{Player:name} stole {Choice:change} points from {Choice:with:name}'
end

class: unique_choice(choice, :reward, :penalty)
meth :name(Choice: unique_choice) "Choose Wisely"
meth :description(Choice: unique_choice) 'If only you choose this option then {Choice:reward:description}, otherwise {Choice:penalty:description}'
meth :cost(Choice: unique_choice) "Free?"
meth :apply(Choice: unique_choice, Player: player) do
	let Players := Player:game:players
	let Index := Player:choices:find(Choice)
	if count(Players ->? fun(Other) Other:choice = Other:choices[Index]) > 1 then
		Choice:penalty:apply(Player)
	else
		Choice:reward:apply(Player)
	end
end

class: lottery(choice, :price, :jackpot, :winners)
meth :name(Choice: lottery) "Lottery"
meth :description(Choice: lottery) 'Enter lottery for a chance to win a share of the jackpot. Roll-over jackpot is {Choice:jackpot}'
meth :cost(Choice: lottery) '{Choice:price} points'
meth :apply(Choice: lottery, Player: player) do
	Player:points := old - Choice:price
	if Player in Choice:winners then
		Player:points := old + (Choice:jackpot / Choice:winners:size)
		ret '{Player:name} bought a lottery ticket for {Choice:cost} and won {Choice:jackpot / Choice:winners:size}'
	else
		ret '{Player:name} bought a lottery ticket for {Choice:cost} but lost'
	end
end

meth :start(Player: player, Game: game) do
	Game:state = game::state::Initial or error("StateError", "Invalid state")
	Game:owner = Player or error("StateError", "Invalid owner")
	Game:state := game::state::Starting
	Game:countdown := Game:limit := 3
	Game:history := []
	Game:round := 0
	Game:events := []
	for Player in Game:players do
		Player:emit("round/starting", {
			"countdown" is Game:countdown, "limit" is Game:limit
		})
	end
	Games:put(Game)
end

meth :leave(Player: player, Game: game) do
	Game = Player:game or error("StateError", "Player not in game")
	Player:game := nil
	let Players := Game:players
	let Index := Players:find(Player)
	Players:delete(Index)
	Player:emit("game/leave", {})
	for Player in Game:players do
		Player:emit("game/leave", {"player" is Index})
	end
	if Players:length = 0 then
		Games:filter(_ != Game)
	end
end

meth :choose(Player: player, Index: any) do
	Player:choice := Player:choices[Index{}]
	ret true
end

def Points := polynomial("Points")
def Rate := polynomial("Rate")

fun round_points(Points) do
	switch Points: integer
	case 1000 .. 100000000 do 1000
	case 500 .. 1000 do 500
	case 250 .. 500 do 250
	case 100 .. 250 do 100
	case 50 .. 100 do 50
	case 25 .. 50 do 25
	case 10 .. 25 do 10
	case 5 .. 10 do 5
	else 1
	end
end

glib::timeout_add(0, 1000;) do
	for Game in Games do
		ref Countdown := Game:countdown
		ref State := Game:state
		let Players := Game:players
		if Countdown and Countdown:dec = 0 then
			switch State: game::state
			case "Starting" do
				Game:round := 1
				Game:rollover := 0
				State := game::state::Running
				Countdown := Game:limit := 10
				for Player in Players do
					Player:points := 0
					Player:rate := 1
					Player:history := []
					Player:choices := []
					Player:choice := nil
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points, "rate" is Player:rate,
						"log" is [], "round" is Game:round,
						"players" is list(Game:players; Player) {
							"points" is Player:points, "rate" is Player:rate
						}
					})
				end
			case "Running" do
				if Game:round:inc <= 10 then
					State := game::state::Choosing
					Countdown := Game:limit := 10
					let MeanPoints := stat::mean(Players, :points)
					let MeanRate := stat::mean(Players, :rate)
					Game:events:empty
					for Player in Players do
						Player:choices:empty
					end
					var Remaining := 4
					loop
						print('Remaining cards = {Remaining}\n')
						while Remaining > 0
						let Choice := switch nil: random
						case 0.2 do
							let A1 := switch nil: random
							case 10 do 1
							case 2 do 1.1
							case 1 do 1.2
							end
							let B1 := round_points(MeanPoints * random(real) / 2)
							let A2 := switch nil: random
							case 5 do 0
							case 1 do 0.1
							case 0.2 do 0.2
							end
							let B2 := MeanRate * random(0 .. 2) / 5
							for Player in Players do
								Player:choices:put(adjust_points(
									A2 * Player:rate + B2,
									A1 * Player:points + B1
								))
							end
						case 0.3 do
							let A1 := switch nil: random
							case 10 do 1
							case 2 do 1.1
							case 1 do 1.2
							end
							let B1 := random(0 .. 5)
							let A2 := switch nil: random
							case 5 do 0
							case 1 do 0.1
							case 0.2 do 0.2
							end
							let B2 := MeanPoints * random(1 .. 3) / 4
							for Player in Players do
								Player:choices:put(adjust_rate(
									A2 * Player:points + B2,
									A1 * Player:rate + B1
								))
							end
						case 0.1 do
							let Best := max2(dup(Players), :points)[1]
							let Choice := swap_points(Best)
							for Player in Players do
								Player:choices:put(Choice)
							end
						case 0.1 do
							let Other := random(Players)
							let Change := switch nil: random
							case 5 do round_points(Other:points / 5)
							case 2 do round_points(Other:points / 3)
							case 1 do round_points(Other:points / 2)
							end
							let Choice := steal_points(Other, Change)
							for Player in Players do
								Player:choices:put(Choice)
							end
						case 0.1 do
							let A1 := switch nil: random
							case 10 do 1.2
							case 2 do 1.3
							case 1 do 1.4
							end
							let B1 := round_points(MeanPoints * random(real))
							let A2 := switch nil: random
							case 10 do 0.8
							case 2 do 0.7
							case 1 do 0.6
							end
							let B2 := round_points(-MeanPoints * random(real) / 2)
							for Player in Players do
								Player:choices:put(unique_choice(
									adjust_points(0, A1 * Player:points + B1),
									adjust_points(0, A2 * Player:points + B2)
								))
							end
						case 0.1 do
							let Change := MeanPoints * random(1 .. 3) / 4
							let Others := list(Players):shuffle
							for Player in Players; Other in Others do
								let Choice := steal_points(Other, Change)
								Player:choices:put(Choice)
							end
						case 0.1 do
							let Others := list(Players):shuffle
							for Player in Players; Other in Others do
								Player:choices:put(swap_points(Other))
							end
						case 0.1 do
							Game:rollover or next
							let Lottery := lottery(10, Game:rollover + 100)
							Game:rollover := nil
							Game:events:put(;) do
								let Entered := list(Players ->? fun(Player) Player:choice = Lottery)
								let Winners := Lottery:winners := set(Entered ->? fun random(real) < 0.05)
								Lottery:jackpot := old + 50 * Entered:count
								if Winners:count = 0 then
									Game:rollover := Lottery:jackpot
									ret 'Nobody won the jackpot of {Lottery:jackpot} points, it rolls over to next time'
								else
									Game:rollover := 0
									ret 'There were {Winners:size} winners of the jackpot of {Lottery:jackpot} points'
								end
							end
							for Player in Players do
								Player:choices:put(Lottery)
							end
						end
						Remaining:dec
					end
					for Player in Players do
						Player:choice := nil
						Player:emit("round/choosing", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points, "rate" is Player:rate,
							"choices" is list(Player:choices; Choice) {
								"name" is Choice:name,
								"description" is Choice:description,
								"cost" is Choice:cost
							},
							"players" is list(Game:players; Player) {
								"points" is Player:points, "rate" is Player:rate
							}
						})
					end
				else
					State := game::state::Scoring
					Countdown := Game:limit := 20
					for Player in Players do
						Player:emit("round/scoring", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points, "rate" is Player:rate,
							"players" is list(Game:players; Player) {
								"name" is Player:name,
								"points" is Player:points, "rate" is Player:rate
							}
						})
					end
				end
			case "Choosing" do
				let Log := []
				for Event in Game:events do
					Log:put(Event())
				end
				for Player in Players do
					if let Choice := Player:choice then
						Log:put(Choice:apply(Player))
					end
				end
				State := game::state::Running
				Countdown := Game:limit := 10
				for Player in Players do
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points, "rate" is Player:rate,
						"log" is Log, "round" is Game:round,
						"players" is list(Game:players; Player) {
							"points" is Player:points, "rate" is Player:rate
						}
					})
				end
			case "Scoring" do
				State := game::state::Ending
				Countdown := Game:limit := 1
				for Player in Players do
					Player:emit("round/ending", {
						"countdown" is Countdown, "limit" is Game:limit,
						"players" is list(Players; Player) {"points" is Player:points}
					})
				end
			case "Ending" do
				State := game::state::Starting
				Countdown := Game:limit := 3
				for Player in Players do
					Player:emit("round/starting", {
						"countdown" is Countdown,  "limit" is Game:limit
					})
				end
			end
		elseif State = game::state::Running then
			for Player in Players do
				Player:points := old + Player:rate
			end
		end
	on Error do
		log::error(Error)
	end
	ret true
end

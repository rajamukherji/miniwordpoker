import: glib("gir/GLib")
import: gobject("gir/GObject")
import: json("fmt/json")
import: uuid("util/uuid")
import: stat("math/stat")
import: dist("math/dist")
logger: log("main")

:<
import: game("game")
let Game := game::game("Test")
let P1 := game::player("Ann")
let P2 := game::player("Bob")
let P3 := game::player("Cat")
let P4 := game::player("Dan")
P1 join Game
P2 join Game
Game:start
>:

export: class: game(
	:name, :owner, :password, :state, :players, :countdown, :limit,
	:round, :history, :questions, :time,
	
	state is enum("Initial", "Starting", "Running", "Choosing", "Scoring", "Ending"),
	init is fun(Game, Name, Owner, Password) do
		Game:name := Name
		Game:owner := Owner
		Game:password := Password
		Game:state := game::state::Initial
		Game:players := []
		Game:history := []
	end
)

export: class: player(:name, :callback, :game, :points,
	:choices, :choice, :time,
	init is fun(Player, Name, Callback) do
		Player:name := Name
		Player:callback := Callback or fun(Player, Event, Data) do
			print(Event, " ", Data, "\n")
		end
	end
)

meth :emit(Player: player, [Args]) do
	Player:callback ! [Player]:grow(Args)
end

meth :state(Player: player) do
	if let Game := Player:game then
		ret {
			"name" is Game:name, "state" is string(Game:state),
			"countdown" is Game:countdown, "limit" is Game:limit,
			"points" is Player:points,
			"owner" is Game:owner = Player and true,
			"players" is list(Game:players; Other) {
				"name" is Other:name, "points" is Other:points
			}
		}
	end
end

meth :join(Player: player, Game: game) do
	Player:game and error("StateError", "Player already in game")
	Player:game := Game
	Player:points := 0
	for Other in Game:players do
		Other:emit("game/join", {"name" is Player:name, "points" is Player:points})
	end
	Game:players:put(Player)
	ret Player:state
end

let Games := []
let Questions := json::decode(file("questions.json", "r"))

meth :start(Player: player, Game: game) do
	Game:state = game::state::Initial or error("StateError", "Invalid state")
	Game:owner = Player or error("StateError", "Invalid owner")
	Game:state := game::state::Starting
	Game:countdown := Game:limit := 3
	Game:questions := list(Questions):shuffle
	Game:round := 0
	for Player in Game:players do
		Player:emit("round/starting", {
			"countdown" is Game:countdown, "limit" is Game:limit
		})
	end
	Games:put(Game)
end

meth :leave(Player: player, Game: game) do
	Game = Player:game or error("StateError", "Player not in game")
	Player:game := nil
	let Players := Game:players
	let Index := Players:find(Player)
	Players:delete(Index)
	Player:emit("game/leave", {})
	for Player in Game:players do
		Player:emit("game/leave", {"player" is Index})
	end
	if Players:length = 0 then
		Games:filter(_ != Game)
	end
end

meth :choose(Player: player, Index: any) do
	let Choice := Player:choices[Index]
	Player:choice = Choice and ret false
	Player:choice := Choice
	Player:time := time()
	ret true
end

glib::timeout_add(0, 1000;) do
	for Game in Games do
		ref Countdown := Game:countdown
		ref State := Game:state
		let Players := Game:players
		if Countdown and Countdown:dec = 0 then
			switch State: game::state
			case "Starting" do
				Game:round := 0
				State := game::state::Running
				Countdown := Game:limit := 1
				for Index, Player in Players do
					Player:points := 0
					Player:choices := []
					Player:choice := nil
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points,
						"round" is Game:round,
						"players" is list(Game:players; Player) {"points" is Player:points}
					})
				end
			case "Running" do
				Game:round:inc
				if let Question := Game:questions[Game:round] then
					State := game::state::Choosing
					Countdown := Game:limit := 10
					let Answers := Question["answers"]
					for Index, Player in Players do
						Player:choice := nil
						Player:choices := list(Answers):shuffle
						Player:emit("round/choosing", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points,
							"round" is Game:round,
							"question" is Question["question"],
							"image" is Question["image"],
							"choices" is Player:choices,
							"players" is list(Game:players; Player) {"points" is Player:points}
						})
					end
					Game:time := time()
				else
					State := game::state::Scoring
					Countdown := Game:limit := 20
					let FinalScores := list(Players; Player) (Player:points, Player:name)
					FinalScores:sort
					let History := {"round" is 'Final Scores', "log" is list(FinalScores; (Points, Name)) '{Name} scored {Points} points.'}
					for Player in Players do
						Player:emit("game/history", [History])
						Player:emit("round/scoring", {
							"countdown" is Countdown, "limit" is Game:limit,
							"points" is Player:points,
							"round" is Game:round,
							"players" is list(Game:players; Player) {
								"name" is Player:name, "points" is Player:points
							}
						})
					end
					Game:history:put(History)
				end
			case "Choosing" do
				let Log := []
				let Question := Game:questions[Game:round]
				let Answer := Question["answers"][1]
				Log:put('The correct answer to \"{Question["question"]}\" is \"{Answer}\"')
				let Correct := []
				for Player in Players do
					if Player:choice = Answer then
						let Time := (Player:time - Game:time) max 0
						let Points := 10 - (Time div 1) max 6
						Correct:put((Time, '{Player:name} took {math::round(Time, 100)}s and won {Points} points!'))
						Player:points:inc(Points)
					end
				end
				Correct:sort
				Log:grow(Correct, _[2])
				State := game::state::Running
				Countdown := Game:limit := 3
				let History := {"round" is 'Round {Game:round}', "log" is Log}
				for Index, Player in Players do
					Player:emit("game/history", [History])
					Player:emit("round/running", {
						"countdown" is Countdown, "limit" is Game:limit,
						"points" is Player:points,
						"round" is Game:round,
						"players" is list(Game:players; Player) {"points" is Player:points}
					})
				end
				Game:history:put(History)
			case "Scoring" do
				State := game::state::Ending
				Countdown := Game:limit := 1
				for Player in Players do
					Player:emit("round/ending", {
						"countdown" is Countdown, "limit" is Game:limit,
						"players" is list(Players; Player) {"points" is Player:points}
					})
				end
			case "Ending" do
				State := game::state::Starting
				Countdown := Game:limit := 3
				for Player in Players do
					Player:emit("round/starting", {
						"countdown" is Countdown,  "limit" is Game:limit
					})
				end
			end
		end
	on Error do
		log::error(Error)
	end
	ret true
end
